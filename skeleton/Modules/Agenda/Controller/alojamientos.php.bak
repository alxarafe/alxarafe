<?php

use Xnet\Core\Controller\XnetResourceController;
use Xnet\Core\Component\Fields\Date;
use Xnet\Core\Component\Fields\DateTime;
use Xnet\Core\Component\Fields\Icon;
use Xnet\Core\Component\Fields\Text;
use Xnet\Core\Form\Field\TextField;
use Xnet\Core\Form\Field\SelectField;
use Xnet\Core\Form\Field\EmailField;
use Xnet\Core\Component\Filter\AutocompleteFilter;
use Xnet\Core\Component\Filter\DateRangeFilter;
use Xnet\Core\Component\Filter\RelationFilter;
use Xnet\Core\Component\Filter\Select2Filter;
use Xnet\Core\Component\Filter\SelectFilter;
use Xnet\Core\Component\Filter\TextFilter;

require_once 'plugins/domaincontroller/model/mf_alojamiento.php';

/**
 * Controlador V2 para listado y edición de alojamientos.
 * Refactorizado para usar XnetResourceController v2026.
 */
class alojamientos extends XnetResourceController
{
    protected function getModelClass()
    {
        return 'mf_alojamiento';
    }

    protected function setup()
    {
        // 1. Define Tabs specific conditions (since getModelClass default is generic)
        // We override the default 'general' tab generated by buildConfiguration or modify it
        // Ideally we just clear tabs and add ours.
        $this->config['list']['tabs'] = [];

        $this->addListTab('activos', 'Activos', 'mf_alojamiento', ['activo' => 1]);
        $this->addListTab('bajas', 'Bajas', 'mf_alojamiento', ['fecha_baja' => 'NOT NULL']);

        // 2. Generic Buttons implicitly added by parent (New, etc.) -> setup() called AFTER buildConfiguration
        parent::setup();

        // --- CUSTOM ACTIONS LOGIC ---
        if (isset($_GET['user_action']) && $_GET['user_action'] === 'actualizar_alojamientos') {
            $this->action_actualizar_alojamientos();
        }

        // --- CUSTOM BUTTONS ---
        $this->addListButton(
            'update_hosting',
            'Sincronizar con WHM',
            'fas fa-sync',
            'outline-danger',
            'right',
            'url',
            'index.php?page=' . $this->class_name . '&user_action=actualizar_alojamientos'
        );

        // Actions per row
        $this->addRowAction('details', 'Detalles', 'fas fa-eye', 'index.php?page=' . $this->class_name . '&id={id}');
    }

    protected function getListFields(): array
    {
        return [
            'activos' => [
                'bloqueado',
                'suspendido',
                'protegido',
                'dominio',
                'whm_usuario',
                'cliente.nombre',
                'partner.nombre',
                'agente.nombre',
                'whm_plan',
                'fecha_alta',
                'version',
                'ultimoacceso',
            ],
            'bajas' => [
                'dominio',
                'cliente.nombre',
                'fecha_baja',
                'motivobaja',
            ]
        ];
    }


    protected function getFilters(): array
    {
        // Data loading for filters
        $partners = (new \mf_partner())->all_names_only();
        $agentes = [];
        foreach ((new \agente())->all() as $a) {
            $agentes[$a->codagente] = $a->get_fullname();
        }
        $referidos = (new \mf_referido())->all_names_only();
        $aplicaciones = (new \aplicacion())->get_all_names();
        $paquetesapp = (new \paqueteapp())->allNamesOnly();

        // Global Search
        $this->addGlobalSearch(['dominio', 'whm_usuario', 'whm_email', 'nombre_basedatos']);

        // We can return a flat array (applied to default tab) or keyed by tab
        // Since we removed 'default' tab in setup and added 'activos'/'bajas', we need filters for 'activos' mostly.

        // Wait, XnetResourceController::buildConfiguration applies filters to $defaultTab
        // But we wipe tabs in setup(). So filters added in buildConfiguration might be lost/orphaned if attached to 'general'.

        // STRATEGY: Directly add filters in setup() OR update XnetResourceController to handle keyed filters array.
        // Current XnetResourceController implementation only applies to $defaultTab (flat list).
        // Let's manually add them here to be safe and specific, or return them and let them attach to 'general' 
        // (which we then rename or map? No, tab 'activos' is new).

        // WORKAROUND: For this specific complex controller with multi-tabs and custom logic, 
        // passing filters via array in buildConfiguration to a tab that gets deleted is risky.
        // I will add them manually in setup or here using $this->addListFilter directly?
        // No, getFilters is expected to return array.

        // I'll leave this empty and add filters in setup() for now to ensure they attach to 'activos' properly, 
        // OR I'll assume I can call addListFilter here directly (side effect).

        $this->addListFilter('activos', new TextFilter('dominio', 'Dominio'));
        $this->addListFilter('activos', new RelationFilter('codcliente', 'cliente', 'Cliente'));
        $this->addListFilter('activos', new TextFilter('codpropietario', 'Cód. Propietario'));
        $this->addListFilter('activos', new TextFilter('codreseller', 'Cód. Reseller'));
        $this->addListFilter('activos', new AutocompleteFilter('codpartner', 'Partner', $partners));
        $this->addListFilter('activos', new AutocompleteFilter('codagente', 'Agente', $agentes));
        $this->addListFilter('activos', new SelectFilter('codreferido', 'Referido', $referidos));
        $this->addListFilter('activos', new Select2Filter('codaplicacion', 'Aplicación', $aplicaciones));
        $this->addListFilter('activos', new AutocompleteFilter('idpaqueteapp', 'Paquete App', $paquetesapp));
        $this->addListFilter('activos', new DateRangeFilter('fecha_alta', 'Fecha Alta'));
        $this->addListFilter('activos', new DateRangeFilter('ultimoacceso', 'Último Acceso'));

        $this->addListFilter('bajas', new TextFilter('dominio', 'Dominio'));
        $this->addListFilter('bajas', new TextFilter('codcliente', 'Cód. Cliente'));
        $this->addListFilter('bajas', new DateRangeFilter('fecha_baja', 'Fecha Baja'));

        return [];
    }

    protected function getEditFields(): array
    {
        // Load data for edit fields
        $partners = (new \mf_partner())->all_names_only();

        // Because we have sections, we return a keyed array? 
        // XnetResourceController::buildConfiguration supports keys for sections?
        // Implementation check: 
        // $fields = $this->getEditFields();
        // $this->setEditFields($fields, $defaultSection);
        // It treats it as a flat list for 'main'.

        // So for multi-section edit, we still rely on setup() or addEditField() calls.
        // Or we pass a flat list and let them go to 'main'.

        // Converting 'main' fields to array return
        return [
            'dominio',
            'whm_usuario' => ['label' => 'Usuario WHM'],
            new EmailField('whm_email', 'Email Admin'),
            'codcliente' => ['label' => 'Cód. Cliente'],
            new SelectField('codpartner', 'Partner', $partners)
        ];
    }
    
    // Supplementing Edit Sections in setup() or overriding logic
    // Since getEditFields only populates 'main', we add the rest in setup or extend getEditFields logic later.
    // I'll add the 'tech' section fields in setup() to handle the specific layout requirements.

    /**
     * Acción personalizada para sincronizar alojamientos
     */
    private function action_actualizar_alojamientos()
    {
        set_temporaly_unlimited_limits();

        $_servers = new \whm_server();
        $servers = $_servers->all();
        foreach ($servers as $server) {
            if (!$server->activo) {
                continue;
            }
            $whm = new \Plugins\domaincontroller\helpers\WHM($server->host_name, $server->user, $server->access_hash);
            $accounts = $whm->listAccounts();

            if (isset($accounts->error)) {
                $message = 'Error';
                if (!empty($accounts->error->message->result->cpanelresult->error)) {
                    $message = $accounts->error->message->result->cpanelresult->error;
                } elseif (!empty($accounts->error->message->error)) {
                    $message = $accounts->error->message->error;
                }
                $account_error = "Error al obtener cuentas de {$server->user}@{$server->host_name} ({$accounts->error->code}) '{$message}'.";
                $this->new_message('Server ' . $server->id . ', ' . $account_error);
            } else {
                $status = [];
                $syncService = new \Plugins\domaincontroller\services\HostingSyncService();
                foreach ($accounts as $account) {
                    $result = $syncService->importAccount($account, $server);
                    $status = array_merge($status, $result);
                }
            }
        }

        $domain = filter_input(INPUT_GET, 'domain');
        $model = new \mf_alojamiento();
        $hosts = $domain == null ? $model->get_cpanel_users() : $model->get_cpanel_users($domain);

        $syncService = new \Plugins\domaincontroller\services\HostingSyncService();
        foreach ($hosts as $host) {
            $result = $syncService->syncSubdomainsForAccount($host['idserver'], $host['whm_usuario'], $host['id']);
            if (is_array($result)) {
                foreach ($result as $key => $msg) {
                    $mensaje = '<a target="_blank" href="index.php?page=' . $this->class_name . '&id=' . $key . '">' . $msg . '</a>';
                    $this->new_error_msg($mensaje);
                }
            }
        }

        $this->new_message('Sincronización finalizada.');
    }
}
